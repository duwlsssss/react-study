# Effect로 동기화하기

## Effect 왜쓰나?

Effect는 주로 컴포넌트를 React를 벗어난 외부 시스템 (사이드이펙트)과 동기화하기 위해 사용 // 구체적으로 데이터 페칭, localStorage같은 브라우저 API와의 상호작용, 제3의 라이브러리 등과 같이쓸때..

## 이벤트와는 뭐가 다른가!

이벤트는 특정 사용자 작업으로 인해 발생하는 부수효과에 의해 특정 코드를 실행시키는 반면, effect는 렌더링에 의해 발생함. + ref와 마찬가지로 커밋(실제 DOM에 변경사항 적용)이 끝난 후에서야 업데이트가 이뤄지고 실행됨.

## 언제 실행되는지?

초기 렌더링 이후, 각각의 요소에 맞추어 DOM에 커밋이 이뤄진다. 그에따라 브라우저가 그려진 후에, Effect 코드가 발생한다.

## 의존성 지정하기

effect는 의존성을 지정하지 않으면, 모든 렌더와 동기화 되게 됩니다. 따라서 불필요한 렌더를 줄이기위해 의존성 지정이 요구됩니다.

```jsx
useEffect(() => {
  // 모든 렌더링 후에 실행됩니다 (지양해야함)
});

useEffect(() => {
  // 마운트될 때만 실행됩니다 (컴포넌트가 나타날 때)
}, []);

useEffect(() => {
  // 마운트될 때 실행되며, *또한* 렌더링 이후에 a 또는 b 중 하나라도 변경된 경우에도 실행됩니다
}, [a, b]);
```

## 클린업!

개발 중에 Effect가 두 번 실행되는 경우

```jsx
import { useEffect } from "react";
import { createConnection } from "./chat.js";

export default function ChatRoom() {
  useEffect(() => {
    const connection = createConnection();
    connection.connect();
  }, []);
  return <h1>채팅에 오신걸 환영합니다!</h1>;
}
```

다음과 같은 코드가 실행되면, 마운트시 한번 우선 실행되고 어느 페이지를 방문하고 다시 뒤로가면 이미 실행된 채로 또 실행되는 경우가 생김. => 따라서 클린업 함수인,

    return () => {
      connection.disconnect();
    };

해당 코드를 반환하여 초기 실행을 종료 시켜주는것입니다.

=>React는 Effect가 다시 실행되기 전마다 클린업 함수를 호출하고, 컴포넌트가 마운트 해제(제거)될 때에도 마지막으로 호출합니다.

이렇게 해줌으로써, 부수적으로 메모리성능 향상에도 도움을 줍니다.

=>**useEffect**는 특정 작업을 시작할 때 도구를 꺼내 사용하는 것이고, 작업이 끝나면 클린업 함수를 통해 도구를 다시 정리합니다.
만약 도구를 정리하지 않으면, 다른 작업을 할 때 혼란이 생기거나, 도구가 계속 남아 공간을 차지하게 될 수 있습니다

### 데이터 페칭시 clean up

```jsx
useEffect(() => {
  let ignore = false;

  async function startFetching() {
    const json = await fetchTodos(userId);
    if (!ignore) {
      setTodos(json);
    }
  }

  startFetching();

  return () => {
    ignore = true;
  };
}, [userId]);
```

ignore 변수를 플래그로 세워 이후 userId가 'Alice'에서 'Bob'으로 변경되면 클린업은 'Bob'이후에 도착하더라도 'Alice' 응답을 무시하도록 보장됩니다.

## 정리

1. 먼저 우리가 컴포넌트를 실행하면 컴포넌트의 훅들이 초기화되고 가상돔이 생성되는 (initial rendering)을 수행 합니다.
2. 이후 가상 돔이 실제 돔에 업데이트 (커밋)하며, 브라우저를 그립니다.
3. 이후 Effect의 의존성 배열에 따라 내부의 코드가 실행됩니다.
4. 다만 effect 내부의 코드가 실행되어있는데, 브라우저가 뒤로가기후 다시 되돌아오는 동작으로 인해 재렌더링이 될 경우 또는 상태가 바뀌어 의존성 배열에 의해 재 실행되면 내부코드가 불필요하게 또는 의도치않게 두번 실행 될 경우가 있어, 이를 방지하기 위해 다시 초기상태로 되돌리는 클린 코드를 반환 할 수 있습니다.
5. 클린 코드는 실행되고 있지 않다가 언마운트시, 또는 effect가 의존성 배열에의해 재 실행될때 실행됩니다.
